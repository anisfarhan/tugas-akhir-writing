%-----------------------------------------------------------------------------%
\chapter{\babEmpat}
\label{bab:4}
%-----------------------------------------------------------------------------%
Bab ini menjelaskan tentang implementasi dari kode-kode yang dipilih pada tugas akhir ini.

\todo{
    Sejatinya bab ini digunakan untuk membahas inti dari penelitian Anda.
    Sesuaikan saja dengan kebutuhkan Anda: misalkan bab empat Anda adalah penjelasan terkait implementasi sistem.
}


%-----------------------------------------------------------------------------%
\section{Sorting - Bubble Sort}
\label{sec:bubble-sort-implementation}
%-----------------------------------------------------------------------------%
\subsection{Deskripsi Algoritma}
Bubble Sort merupakan algoritma pengurutan sederhana yang efektif untuk dataset kecil. Algoritma ini bekerja dengan cara melakukan iterasi berulang pada larik data dan menukar pasangan elemen bersebelahan jika berada dalam urutan yang salah. Proses ini diulang hingga seluruh elemen berada dalam urutan yang benar. Kompleksitas waktu dalam kasus terburuk dan rata-rata adalah $\mathcal{O}\left(N^2\right)$, sedangkan kompleksitas ruang adalah ${O}\left(1\right)$.

\subsection{Pseudocode}
\begin{verbatim}
    procedure bubbleSort(arr, n):
        for i from 0 to n-1:
            for j from 0 to n-i-1:
                if arr[j] > arr[j+1]:
                    swap arr[j] and arr[j+1]
\end{verbatim}

\subsection{Contoh Input-Output}
\textbf{Input:}
\begin{verbatim}
    6
    3 2 1 5 6 4
\end{verbatim}

\textbf{Output:}
\begin{verbatim}
    1 2 3 4 5 6
\end{verbatim}

\section{Matrix Multiplication - Naive}
\label{sec:matrix-multiplication-implementation}

\subsection{Deskripsi Algoritma}
Matrix Multiplication adalah proses mengalikan dua matriks untuk menghasilkan matriks baru. Jika matriks A berukuran $m \times n$ dan matriks B berukuran $n \times p$, maka hasil kali matriks C = A * B akan berukuran $m \times p$. Proses ini melibatkan penjumlahan produk elemen baris dari matriks A dengan elemen kolom dari matriks B. Kompleksitas waktu untuk metode naive adalah $\mathcal{O}\left(N^3\right)$, sedangkan kompleksitas ruang adalah $\mathcal{O}\left(N^2\right)$.

\subsection{Pseudocode}
\begin{verbatim}
    function matrixMultiply(A, B):
        for i from 0 to A.rows-1:
            for j from 0 to B.cols-1:
                C[i][j] = 0
                for k from 0 to A.cols-1:
                    C[i][j] += A[i][k] * B[k][j]

        return C
\end{verbatim}

\subsection{Contoh Input-Output}
\textbf{Input:}
\begin{verbatim}
    matrix A size:
    2 3
    matrix A:
    1 2 3
    4 5 6

    matrix B size:
    3 2
    matrix B:
    1 1
    1 2
    2 3
\end{verbatim}

\textbf{Output:}
\begin{verbatim}
    result matrix:
    9 14
    21 32
\end{verbatim}

\section{Integral Modeling - Trapezoidal Rule Integration}
\label{sec:trapezoidal-rule-integration-implementation}

\subsection{Deskripsi Algoritma}
Trapezoidal Rule adalah metode numerik untuk menghitung integral dari fungsi. Metode ini bekerja dengan membagi area di bawah kurva menjadi beberapa trapezoid, kemudian menjumlahkan luas trapezoid tersebut untuk mendapatkan perkiraan nilai integral. Kompleksitas waktu dari metode ini adalah $\mathcal{O}(n)$, di mana $n$ adalah jumlah subinterval (dengan asumsi perhitungan nilai fungsi dilakukan dalam $\mathcal{O}(1)$), dan kompleksitas ruangnya adalah $\mathcal{O}(1)$.

\subsection{Pseudocode}
\begin{verbatim}
    function trapezoidalRule(f, a, b, n):
        h = (b - a) / n
        sum = f(a) + f(b)
        for i from 1 to n-1:
            sum += 2 * f(a + i * h)
        return sum * h / 2
\end{verbatim}

\subsection{Contoh Input-Output}
\textbf{Input:}
\begin{verbatim}
    f(x) = x^2
    a = 0
    b = 1
    n = 1000
\end{verbatim}

\textbf{Output:}
\begin{verbatim}
    0.333333
\end{verbatim}

\section{Graph Traversal - Depth-First Search (DFS)}
\label{sec:dfs-implementation}

\subsection{Deskripsi Algoritma}
Depth-First Search (DFS) adalah algoritma pencarian yang digunakan untuk menjelajahi graf atau pohon. DFS bekerja dengan cara menjelajahi sejauh mungkin di sepanjang cabang sebelum melakukan backtrack. Algoritma ini menggunakan struktur data stack (atau rekursi) untuk melacak jalur yang sedang dieksplorasi. Kompleksitas waktu DFS adalah $\mathcal{O}\left(V + E\right)$, di mana $V$ adalah jumlah vertex dan $E$ adalah jumlah edge. Kompleksitas ruangnya adalah $\mathcal{O}\left(V\right)$ untuk menyimpan status kunjungan.

\subsection{Pseudocode}
\begin{verbatim}
    procedure DFS(graph, start):
        create a stack S
        push start onto S
        mark start as visited

        while S is not empty:
            vertex = pop S
            for each neighbor of vertex:
                if neighbor is not visited:
                    mark neighbor as visited
                    push neighbor onto S
\end{verbatim}

\subsection{Contoh Input-Output}
Pada contoh ini algoritma DFS digunakan untuk menghitung luas pulau dari koordinat (x, y) yang diberikan. Dimana 1 menandakan daratan dan 0 menandakan lautan.
\textbf{Input:}
\begin{verbatim}
    grid size:
    5 5
    grid:
    1 1 0 0 0
    1 1 0 1 0
    0 0 0 1 1
    0 0 1 1 1
    1 1 0 0 0
    start point:
    1 1
\end{verbatim}

\textbf{Output:}
\begin{verbatim}
    area of island: 4
\end{verbatim}

\section{Dynamic Programming - Coin Change}
\label{sec:coin-change-implementation}

\subsection{Deskripsi Algoritma}
Contoh masalah algoritma dynamic programming diberikan dalam bentuk Coin Change Problem. Masalah ini bertujuan untuk menemukan jumlah minimum koin yang dibutuhkan untuk mencapai nilai tertentu dengan denominasi koin yang diberikan. Kompleksitas waktu adalah $\mathcal{O}\left(N \cdot M\right)$, di mana $N$ adalah jumlah nilai yang ingin dicapai dan $M$ adalah jumlah jenis koin. Kompleksitas ruangnya adalah $\mathcal{O}\left(N\right)$.


\subsection{Pseudocode}
\begin{verbatim}
    function coinChange(coins, amount):
        dp = array of size (amount + 1) initialized to infinity
        dp[0] = 0

        for i from 1 to amount:
            for each coin in coins:
                if i - coin >= 0:
                    dp[i] = min(dp[i], dp[i - coin] + 1)

        return dp[amount] if dp[amount] != infinity else -1
\end{verbatim}

\subsection{Contoh Input-Output}
\textbf{Input:}
\begin{verbatim}
    coins:
    1 3 4
    amount:
    6
\end{verbatim}

\textbf{Output:}
\begin{verbatim}
    minimum number of coins: 2
\end{verbatim}

\section{String Matching - Naive}
\label{sec:string-matching-implementation}

\subsection{Deskripsi Algoritma}
Naive String Matching adalah algoritma yang digunakan untuk mencari substring dalam string utama dengan cara membandingkan setiap karakter dari substring dengan karakter yang sesuai dalam string utama. Algoritma ini bekerja dengan iterasi melalui string utama dan memeriksa kecocokan karakter satu per satu. Kompleksitas waktu dalam kasus terburuk adalah $\mathcal{O}\left(N \cdot M\right)$, di mana $N$ adalah panjang string utama dan $M$ adalah panjang substring. Kompleksitas ruangnya adalah $\mathcal{O}(1)$.

\subsection{Pseudocode}
\begin{verbatim}
    function stringMatch(text, pattern):
        n = length of text
        m = length of pattern
        for i from 0 to n - m:
            j = 0
            while j < m and text[i + j] == pattern[j]:
                j += 1
            if j == m:
                return i  // found match at index i
        return -1  // no match found
\end{verbatim}

\subsection{Contoh Input-Output}
\textbf{Input:}
\begin{verbatim}
    text: "hello world"
    pattern: "world"
\end{verbatim}

\textbf{Output:}
\begin{verbatim}
    match found at index: 6
\end{verbatim}

\section{Path-Finding Algorithm - Dijkstra's Algorithm}
\label{sec:dijkstra-implementation}

\subsection{Deskripsi Algoritma}
Tuliskan penjelasan singkat tentang algoritma tersebut: cara kerja, kompleksitas waktu/ruang jika perlu, dan alasan penggunaannya secara umum.
Algoritma Dijkstra adalah algoritma yang digunakan untuk menemukan jalur terpendek dari satu vertex ke semua vertex lainnya dalam graf berbobot. Algoritma ini bekerja dengan cara menginisialisasi jarak dari simpul awal ke semua simpul lain sebagai tak hingga, kemudian secara iteratif memperbarui jarak terpendek yang ditemukan. Kompleksitas waktu Algoritma Dijkstra adalah $\mathcal{O}\left((V + E) \log V\right)$ dengan menggunakan priority queue, di mana $V$ adalah jumlah vertex dan $E$ adalah jumlah edge. Kompleksitas ruangnya adalah $\mathcal{O}\left(V + E\right)$.

\subsection{Pseudocode}
\begin{verbatim}
    function dijkstra(graph, start):
        dist = array of size V initialized to infinity
        dist[start] = 0
        priorityQueue = min-heap containing (0, start)

        while priorityQueue is not empty:
            (currentDist, currentVertex) = extract-min(priorityQueue)
            for each neighbor of currentVertex:
                newDist = currentDist + weight(currentVertex, neighbor)
                if newDist < dist[neighbor]:
                    dist[neighbor] = newDist
                    update priorityQueue with (newDist, neighbor)

        return dist
\end{verbatim}

\subsection{Contoh Input-Output}
\textbf{Input:}
\begin{verbatim}
    vertex count: 5
    edge count: 6
    edges: // (u, v, weight)
    1 2 2
    1 3 4
    2 3 1
    2 4 7
    3 5 3
    4 5 1
    start vertex: 1
\end{verbatim}

\textbf{Output:}
\begin{verbatim}
    shortest distances from source vertex 1:
    vertex 1: 0
    vertex 2: 2
    vertex 3: 3
    vertex 4: 7
    vertex 5: 6
\end{verbatim}

\section{Data Compression - Huffman Coding}
\label{sec:huffman-coding-implementation}

\subsection{Deskripsi Algoritma}
Tuliskan penjelasan singkat tentang algoritma tersebut: cara kerja, kompleksitas waktu/ruang jika perlu, dan alasan penggunaannya secara umum.
Huffman Coding adalah algoritma kompresi data yang digunakan untuk mengurangi ukuran data dengan cara menggantikan karakter yang sering muncul dengan kode biner yang lebih pendek. Algoritma ini membangun Huffman tree berdasarkan frekuensi kemunculan karakter dalam data. Kompleksitas waktu untuk membangun pohon Huffman adalah $\mathcal{O}\left(N \log N\right)$, di mana $N$ adalah jumlah karakter unik, dan kompleksitas ruangnya adalah $\mathcal{O}\left(N\right)$.

\subsection{Pseudocode}
\begin{verbatim}
    function huffmanCoding(frequencies):
        create a priority queue Q
        for each character and frequency in frequencies:
            insert (frequency, character) into Q

        while Q has more than one element:
            (freq1, char1) = extract-min(Q)
            (freq2, char2) = extract-min(Q)
            newNode = createNode(freq1 + freq2, char1 + char2)
            insert newNode into Q

        return root of the Huffman tree

    procedure generateCodes(node, code, codes):
        if node is a leaf:
            codes[node.character] = code
            return
        generateCodes(node.left, code + '0', codes)
        generateCodes(node.right, code + '1', codes)
\end{verbatim}

\subsection{Contoh Input-Output}
\textbf{Input:}
\begin{verbatim}
    text to compress: "aaaabbbccd"
\end{verbatim}

\textbf{Output:}
\begin{verbatim}
    Huffman Codes:
    'a': 0
    'b': 10
    'c': 111
    'd': 110
    Compressed text:
    "0000101010111111110"
\end{verbatim}

% \section{[Nama Algoritma]}

% \subsection{Deskripsi Algoritma}
% Tuliskan penjelasan singkat tentang algoritma tersebut: cara kerja, kompleksitas waktu/ruang jika perlu, dan alasan penggunaannya secara umum.

% \subsection{Pseudocode}
% \begin{verbatim}
% [Tulis pseudocode di sini dalam gaya umum, tidak spesifik bahasa]
% \end{verbatim}

% \subsection{Contoh Input-Output}
% \textbf{Input:}
% \begin{verbatim}
% [Tulis input seperti yang kamu uji di CLI]
% \end{verbatim}

% \textbf{Output:}
% \begin{verbatim}
% [Tulis hasil yang ditampilkan oleh program]
% \end{verbatim}

% sorting (bubble sort)
% perkalian matrix (naive matrix multiplication)
% integral numerik
% graph traversal (DFS, BFS)
% knapsack problem
% string matching
% path-finding algorithm
% huffman coding
