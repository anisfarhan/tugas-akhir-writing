%-----------------------------------------------------------------------------%
\chapter{\babEmpat}
\label{bab:4}
%-----------------------------------------------------------------------------%
Bab ini menjelaskan tentang implementasi dari kode-kode yang dipilih pada tugas akhir ini.

\todo{
    Sejatinya bab ini digunakan untuk membahas inti dari penelitian Anda.
    Sesuaikan saja dengan kebutuhkan Anda: misalkan bab empat Anda adalah penjelasan terkait implementasi sistem.
}


%-----------------------------------------------------------------------------%
\section{Bubble Sort}
\label{sec:bubble-sort-implementation}
%-----------------------------------------------------------------------------%
\subsection{Deskripsi Algoritma}
Bubble Sort merupakan algoritma pengurutan sederhana yang efektif untuk dataset kecil. Algoritma ini bekerja dengan cara melakukan iterasi berulang pada larik data dan menukar pasangan elemen bersebelahan jika berada dalam urutan yang salah. Proses ini diulang hingga seluruh elemen berada dalam urutan yang benar. Kompleksitas waktu dalam kasus terburuk dan rata-rata adalah $\mathcal{O}\left(N^2\right)$, sedangkan kompleksitas ruang adalah ${O}\left(1\right)$.

\subsection{Pseudocode}
\begin{verbatim}
    procedure bubbleSort(arr, n):
        for i from 0 to n-1:
            for j from 0 to n-i-1:
                if arr[j] > arr[j+1]:
                    swap arr[j] and arr[j+1]
\end{verbatim}

\subsection{Contoh Input-Output}
\textbf{Input:}
\begin{verbatim}
    6
    3 2 1 5 6 4
\end{verbatim}

\textbf{Output:}
\begin{verbatim}
    1 2 3 4 5 6
\end{verbatim}

\section{Matrix Multiplication}
\label{sec:matrix-multiplication-implementation}

\subsection{Deskripsi Algoritma}
Matrix Multiplication adalah proses mengalikan dua matriks untuk menghasilkan matriks baru. Jika matriks A berukuran $m \times n$ dan matriks B berukuran $n \times p$, maka hasil kali matriks C = A * B akan berukuran $m \times p$. Proses ini melibatkan penjumlahan produk elemen baris dari matriks A dengan elemen kolom dari matriks B. Kompleksitas waktu untuk metode naive adalah $\mathcal{O}\left(N^3\right)$, sedangkan kompleksitas ruang adalah $\mathcal{O}\left(N^2\right)$.

\subsection{Pseudocode}
\begin{verbatim}
    function matrixMultiply(A, B):
        for i from 0 to A.rows-1:
            for j from 0 to B.cols-1:
                C[i][j] = 0
                for k from 0 to A.cols-1:
                    C[i][j] += A[i][k] * B[k][j]

        return C
\end{verbatim}

\subsection{Contoh Input-Output}
\textbf{Input:}
\begin{verbatim}
    matrix A size:
    2 3
    matrix A:
    1 2 3
    4 5 6

    matrix B size:
    3 2
    matrix B:
    1 1
    1 2
    2 3
\end{verbatim}

\textbf{Output:}
\begin{verbatim}
    result matrix:
    9 14
    21 32
\end{verbatim}

\section{Trapezoidal Rule Integration}
\label{sec:trapezoidal-rule-integration-implementation}

\subsection{Deskripsi Algoritma}
Trapezoidal Rule adalah metode numerik untuk menghitung integral dari fungsi. Metode ini bekerja dengan membagi area di bawah kurva menjadi beberapa trapezoid, kemudian menjumlahkan luas trapezoid tersebut untuk mendapatkan perkiraan nilai integral. Kompleksitas waktu dari metode ini adalah $\mathcal{O}(n)$, di mana $n$ adalah jumlah subinterval (dengan asumsi perhitungan nilai fungsi dilakukan dalam $\mathcal{O}(1)$), dan kompleksitas ruangnya adalah $\mathcal{O}(1)$.

\subsection{Pseudocode}
\begin{verbatim}
    function trapezoidalRule(f, a, b, n):
        h = (b - a) / n
        sum = f(a) + f(b)
        for i from 1 to n-1:
            sum += 2 * f(a + i * h)
        return sum * h / 2
\end{verbatim}

\subsection{Contoh Input-Output}
\textbf{Input:}
\begin{verbatim}
    f(x) = x^2
    a = 0
    b = 1
    n = 1000
\end{verbatim}

\textbf{Output:}
\begin{verbatim}
    0.333333
\end{verbatim}

\section{Depth-First Search (DFS)}
\label{sec:dfs-implementation}

\subsection{Deskripsi Algoritma}
Depth-First Search (DFS) adalah algoritma pencarian yang digunakan untuk menjelajahi graf atau pohon. DFS bekerja dengan cara menjelajahi sejauh mungkin di sepanjang cabang sebelum melakukan backtrack. Algoritma ini menggunakan struktur data stack (atau rekursi) untuk melacak jalur yang sedang dieksplorasi. Kompleksitas waktu DFS adalah $\mathcal{O}\left(V + E\right)$, di mana $V$ adalah jumlah vertex dan $E$ adalah jumlah edge. Kompleksitas ruangnya adalah $\mathcal{O}\left(V\right)$ untuk menyimpan status kunjungan.

\subsection{Pseudocode}
\begin{verbatim}
    procedure DFS(graph, start):
        create a stack S
        push start onto S
        mark start as visited

        while S is not empty:
            vertex = pop S
            for each neighbor of vertex:
                if neighbor is not visited:
                    mark neighbor as visited
                    push neighbor onto S
\end{verbatim}

\subsection{Contoh Input-Output}
Pada contoh ini algoritma DFS digunakan untuk menghitung luas pulau dari koordinat (x, y) yang diberikan. Dimana 1 menandakan daratan dan 0 menandakan lautan.
\textbf{Input:}
\begin{verbatim}
    grid size:
    5 5
    grid:
    1 1 0 0 0
    1 1 0 1 0
    0 0 0 1 1
    0 0 1 1 1
    1 1 0 0 0
    start point:
    1 1
\end{verbatim}

\textbf{Output:}
\begin{verbatim}
    area of island: 4
\end{verbatim}

\section{Dynamic Programming - Coin Change}
\label{sec:coin-change-implementation}

\subsection{Deskripsi Algoritma}
Contoh masalah algoritma dynamic programming diberikan dalam bentuk Coin Change Problem. Masalah ini bertujuan untuk menemukan jumlah minimum koin yang dibutuhkan untuk mencapai nilai tertentu dengan denominasi koin yang diberikan. Kompleksitas waktu adalah $\mathcal{O}\left(N \cdot M\right)$, di mana $N$ adalah jumlah nilai yang ingin dicapai dan $M$ adalah jumlah jenis koin. Kompleksitas ruangnya adalah $\mathcal{O}\left(N\right)$.


\subsection{Pseudocode}
\begin{verbatim}
function coinChange(coins, amount):
    dp = array of size (amount + 1) initialized to infinity
    dp[0] = 0

    for i from 1 to amount:
        for each coin in coins:
            if i - coin >= 0:
                dp[i] = min(dp[i], dp[i - coin] + 1)

    return dp[amount] if dp[amount] != infinity else -1
\end{verbatim}

\subsection{Contoh Input-Output}
\textbf{Input:}
\begin{verbatim}
    coins:
    1 3 4
    amount:
    6
\end{verbatim}

\textbf{Output:}
\begin{verbatim}
    minimum number of coins: 2
\end{verbatim}

% \section{[Nama Algoritma]}

% \subsection{Deskripsi Algoritma}
% Tuliskan penjelasan singkat tentang algoritma tersebut: cara kerja, kompleksitas waktu/ruang jika perlu, dan alasan penggunaannya secara umum.

% \subsection{Pseudocode}
% \begin{verbatim}
% [Tulis pseudocode di sini dalam gaya umum, tidak spesifik bahasa]
% \end{verbatim}

% \subsection{Contoh Input-Output}
% \textbf{Input:}
% \begin{verbatim}
% [Tulis input seperti yang kamu uji di CLI]
% \end{verbatim}

% \textbf{Output:}
% \begin{verbatim}
% [Tulis hasil yang ditampilkan oleh program]
% \end{verbatim}

% sorting (bubble sort)
% perkalian matrix (naive matrix multiplication)
% integral numerik
% graph traversal (DFS, BFS)
% knapsack problem
% string matching
% path-finding algorithm
% huffman coding
